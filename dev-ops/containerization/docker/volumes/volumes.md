## Volumes

Volumes are the preferred mechanism for persistent data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker.

When a container is started, Docker loads the read-only image layer, adds a read-write layer on top of the image stack, and mounts volumes on the container filesystem.

Containers are usually immutable (to change, only re-deploy). However, databases are not, and Docker gives features to ensure 'separation of concerns'. Two ways to solve it: **Volumes and Bind Mounts** that will outlive the executable.

Volumes make special location outside of container Union File System. Bind Mounts link container path to host path i.e. maps files from host directory into a directory in the container. When container gets deleted, volume does not get automatically deleted.

```bash
$ docker volume create [OPTIONS] [VOLUME]

$ docker volume create my-vol
$ docker volume ls
$ docker volume inspect my-vol
$ docker volume rm my-vol

$ docker volume rm <vol_name1> <vol_name2>
$ docker volume prune    # removes all volumes not used by at least 1 container
```

### Volumes vs Bind Mounts

- Volumes are easier to backup or migrate than bind mounts.
- Can manage volumes using Docker CLI or API.
- Volumes work on both Linux and Windows.
- Volumes can be more safely shared among multiple containers.
- New volumes can have their content pre-popoulated by a container.
- Volumes have much higher performance than bind mounts.

## Bind Mounts

A Docker bind mount is a high-performance connection from the container to a directory on the host machine i.e. uses the host file system. It allows the host to share its own file system with the container, which can be made read-only or read-write.

```bash
$ # pwd is the source on the host
$ # /var/opt/project is the target mount point of the container
$ # after running, file.txt will exist in the pwd of our host machine

$ docker run -v $(pwd):/var/opt/project bash:latest \
  bash -c "echo Hello > /var/opt/project/file.txt"
```

### Example

Mounting local host directory and accessing the contents from within the container. Changes on host machine are reflected in the container, and vice versa.

```bash
$ docker run -d --name bindmount -v "C:\Users\daronphang\Documents":/celery nginx:1.16.0
$ docker exec -it bindmount bash
$ cd ~
$ cd /celery
$ ls  # all contents in Documents will be listed here
```

### Selinux

For servers running with SELinux. Need to perform additional configurations to bypass. Throws "permission denied" error when mounting host FS to container. Need to use z flag.

```bash
$ docker run -v -d ${pwd}:/var/data:Z some_image
```

## Docker Volumes

Docker volumes are native to Docker. Data is kept somewhere on storage attached to the host (often the local filesystem) but is not usable by the host directly. Volumes can be shared between containers. Volume itself has a lifecycle that is longer than the container's.

Using the -v command contains three components:

- Source directory or volume name
- Mount point within the container
- ro if the mount is to be read-only (optional)

When a host folder is mounted onto the container's path, all the content will be available in the container's path. **This is needed if the container needs to read a file from host, or to write to host's directory**.

```bash
$ docker run -v /folder/with/files:/container/path image_name

$ docker run -v $(pwd):/var/opt/project bash:latest \
  bash -c "ls /var/opt/project"

$ docker volume inspect <VOLUME NAME> # check path of mountpoint
```

### Host-Mounted Volumes

Host path can be defined as an absolute or as relative path. By default, the volumes are created inside the local host directory. Hence, don't have to specify the host directory.

```
Linux                   /var/lib/docker/volume
Windows without WSL     C:\ProgramData\Docker\volumes\
Windows with WSL        \\wsl$\docker-desktop-data\data\docker\volumes
```

```
/host/path:/container/path

/var/lib/mysql
/var/opt/my_website/dist:/usr/share/nginx/html:ro
```

### Implicit Docker Volume

Internal volumes have the scope of a single Docker-compose file. If the source is a name, Docker tries to find the volume and creates if it doesn't exist.

```bash
$ docker run -it --rm --name nginx -p 8080:80 -v demo-earthly:/usr/share/nginx/html nginx
```

### Explicit Docker Volume

External volumes can be used across the Docker installation and they need to be created by the user (otherwise fails) using the "docker volume create" command.

```bash
$ docker volume create --name demo-earthly
```
