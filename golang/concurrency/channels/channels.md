## Channels

Channels are the connections between goroutines i.e. a communication mechanism that lets one goroutine send values to another goroutine.

### Send, Receive

A channel has two principal operations, "send" and "receive". A send statement transmits a value from one goroutine, through the channel, to another executing a corresponding receive expression. A receive expression whose result is not used is a valid statement.

Channels support a third operation "close" which sets a flag indicating that no more values will ever be sent on this channel; subsequent attempts to send will panic. Receive operations on a close channel yield the values that have been sent until no more values are left.

By default, **sends and receives block until the other side is ready**:

- If A is sending, but B is doing something else, A will wait until B is ready
- If B is receiving, but A has not sent yet, B will wait until A sends

This allows goroutines to synchronize without explicit locks or condition variables.

```go
ch := make(chan int)    // ch has type 'chan int', unbuffered channel
ch := make(chan int, 0)  // unbuffered channel
ch := make(chan int, 3)  // buffered channel with capacity 3

ch <- x   // a send statement
x := <-ch    // a receive expression in an assignment statement
<-ch    // a receive statement, result is discarded
```

### Close

A sender can close a channel to indicate that no more values will be sent. The boolean is used to determine if the value received from a channel is generated by a send, or if it is the default value (nil value for each type) generated from a closed channel. This helps downstream processes know when to move on, exit, re-open communications on a new or different channel, etc.

Only the **sender should close a channel, never the receiver**. Sending on a closed channel will cause a panic. Also, you don't usually need to close channels like files.

```go
ch := make(chan int)
ch <- data
v, ok := <-ch
close(ch)
fmt.Printf("(%v): %v", ok, v)
// (false): 0
```

### Range

If you have a single channel, using range will suffice. You can loop the range to receive the values from the channel repeatedly, and it will automatically break the loop when a channel is closed.

```go
for _ = range ch {
  // do something
}
```

## Buffered channels

Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.

A buffered channel has a queue of elements. The queue's maximum size is determined when it is created, by the capacity argument to make.

A send operation inserts an element at the back of the queue, and a receive operation removes an element from the front. If the channel is full, the send operation blocks its goroutine until space is made available by another goroutine's receive.

```go
// can send up to 3 values on this channel without goroutine blocking
ch = make(chan string, 3)

ch <- "A"
ch <- "B"
ch <- "C"

fmt.Println(<-ch) // receive "A", frees up one space
```

## Unbuffered Channels

Unbuffered channel is a buffered channel with a capacity of 0.

A send operation blocks the sending goroutine until another goroutine executes a corresponding receive on the same channel, at which point the value is transmitted and both goroutines may continue. Conversely, if the receive operation is attempted first, the receiving goroutine is blocked until a send is transmitted.

```go
func main() {
    conn, err := net.Dial("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    done := make(chan struct{})
    go func() {
        io.Copy(os.Stdout, conn) // NOTE: ignoring errors
        log.Println("done")
        done <- struct{}{} // signal the main goroutine
    }()
    mustCopy(conn, os.Stdin)
    conn.Close()
    <-done // wait for background goroutine to finish
}
```

## Buffered vs unbuffered

The choice between unbuffered and buffered channels may affect the correctness of a program. Unbuffered channels give stronger synchronization guarantees while in buffered channels, the operations are decoupled.

## Unidirectional channel types

To document the intent exclusively and prevent misuse.

```go
// send-only channel of int, allows sends but not receives
func counter(out chan<- int) {
    for x := 0; x < 100; x++ {
        out <- x
    }
    close(out)
}

// receive-only channel of int, allows receives but not sends
func squarer(out chan<- int, in <-chan int) {
    for v := range in {
        out <- v * v
    }
    close(out)
}

func printer(in <-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}

func main() {
    naturals := make(chan int)
    squares := make(chan int)

    go counter(naturals)
    go squarer(squares, naturals)
    printer(squares)
}
```
