## JWT (JSON Web Token)

A token is an authorization file that cannot be tampered with. It is generated by the server using a secret key, sent to and stored by the client.

JWT is an open industry standard that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. The information can be verified and trusted as it is digitally signed. It contains all the required information about an entity to avoid querying a database more than once. The recipient of a JWT does not need to call a server to validate the token.

JWT can be sent through a URL, POST parameter, or inside an HTTP header (using Bearer schema). It is widely used in RESTful APIs.

### Signature

JWTs can be signed using a secret (with HMAC algorithm) or with a public/private key pair using RSA/ECDSA. Signed tokens can verify the integrity of the claims contained within it.

JWTs are signed to protect against data manipulation. With this, the data can be easily read or decoded. **You should not include sensitive information as the data is not encrypted**.

### Encryption

JWTs can be encrypted to provide additional secrecy between parties by hiding claims in the JSON object from other parties.

### How JWT Works

- User authenticates using their credentials
- Authentication server returns a JWT
- User requests to access a resource and sends JWT (typically in Authorization header)
- If token is sent in the Authorization header, CORS won't be an issue as it doesn't use cookies
- Server checks for a valid JWT by verifying that the JWT's signature matches its payload and header
- If successfully verified, server provides resource access to user
- If JWT contains necessary data, the need to query the database can be reduced

## Use Cases

### Authorization

This is the most common scenario for using JWT. Once the user is logged in, each subsequent request will include the JWT, allowing the user to access routes, services and resources. SSO is a feature that widely uses JWT because of its small overhead and ability to be easily used across multiple domains.

### Information exchange

JWTs are a good way of securely transmitting information between parties.

## JWT Structure

All contents in JWT are base64url encoded.

### Header

Typically consists of two parts: type of token and signing algorithm.

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### Payload

Contains the claims which are statements about an entity, and additional metadata. There are three types of claims: registered, public and private. **Claim names should only be three characters long as JWT is meant to be compact**.

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

### Signature

Signature is created by taking the encoded header, encoded payload, a secret and the algorithm specified in the header and signing them.

The signature is used to verify the message was not tampered along the way, and in the case of tokens signed with a private key, it can also verify that the sender of JWT is who it says it is.

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

#### Registered claims

Registered claims are a set of predefined claims which are not mandatory but recommended i.e. iss (issuer), exp (expiration), sub (subject), etc.

#### Public claims

Can be defined at will by those using JWTs.

#### Private claims

Custom claims created to share information between parties that agree on using them and are neither registered or public.

## Storing JWT on Client-Side

### Local storage

Should not use local storage for various reasons:

- Can only store string data
- Synchronous operation which may slow down app's runtime
- Cannot be used by web workers
- Any JS code can access local storage and has no data protection whatsoever (huge security issue and vulnerable to XSS attacks)

### Cookie

Should be stored in httpOnly cookie (special cookie that's only sent in HTTP requests to server) and sent via an encrypted channel such as HTTPS. However, it is still vulnerable to CSRF attacks.

If tokens are stored in cookie, need to implement CSRF token to prevent Cross-Site Request Forgery since any API call browser makes will include cookies and hence, be authenticated by default. CSRF tokens are generated each time browser loads a page and are verified for every POST request by default.

## Session vs JWT

- JWT scales better as tokens are stored on client-side while session uses server memory/database which requires additional querying
- JWT requires larger byte size (~51x compared to user session) and hence, requires more bandwidth
- JWT requires more computing power/time to validate signatures and not ideal for single-threaded environments
- JWTs are better for server-server and client-server communication in API services without needing to perform network validation
- JWTs can be used to store client claims i.e. ID, department, address, etc. that cannot be modified
- JWT is easier to implement as there are libraries in every language
- Cannot invalidate/revoke JWT tokens until they are expired i.e. JWTs are self-contained

## Hybrid Session & JWT

Session ID is stored on frontend. Backend validates session ID and replaces it with JWT token to authorize further requests. Advantages/disadvantages:

- Can easily revoke sessions
- Backend services can authorize requests based only on JWT token
- Skip logic and user flow when JWT token expires on frontend and needs a refresh
- However, authentication service will be under heavy pressure as JWT token is issued for each request
