## Cross-Site Request Forgery (CSRF)

CSRF is an attack that impersonates a trusted user and sends a website unwanted commands by abusing sessions. It occurs when a malicious web site, email, blog, instant message, or program **tricks an authenticated user's web browser** into performing an unwanted action on a trusted site. It exploits the vulnerability that sites **cannot distinguish** between legitimate authorized requests and forged authenticated requests as HTTP requests are stateless.

Since browser requests automatically include all cookies including session cookies, this attack works unless proper authorization is used, which means that the target site's challenge-response mechanism does not verify the identity and authority of the requester.

However, successful **CSRF attacks can only exploit the capabilities exposed by the vulnerable application and the user's privileges**. Depending on the user's credentials, the attacker can transfer funds, change a password, make an unauthorized purchase, elevate privileges for a target account, or take any action that the user is permitted to do.

### CSRF attack with POST request

1. User logs into web application and receives cookie as response after authentication
2. Attacker creates malicious website and perform social engineering to send link to user
3. User visits malicious website that sends POST request to vulnerable site on page load

```html
<img src="https://www.example.com/index.php?action=delete&id=123" />
```

4. If user is logged into the vulnerable site, their browser will automatically include session cookie in request (assuming sameSite is disabled)
5. Server validates user and performs operation

## Mitigation

https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html

### Anti-CSRF Tokens (Synchronizer token pattern)

A CSRF token is a unique value generated by server-side application and shared with the client. When issuing a request to perform a sensitive action i.e. form submission, the client must include the correct CSRF token. CSRF tokens prevent CSRF as an attacker creating a forged request will not have any knowledge about the CSRF token.

Tokens can be generated once per user session or for each request (may result in usability concerns when user clicks on "Back" button which may contain a CSRF token that is invalid). **CSRF token should not be transmitted using cookies but through custom headers (more secure than hidden input field)**.

Server must always check that the CSRF value submitted by form (set in URL/body/header) must match with the token stored as cookie/session. Need to set as HttpOnly.

#### How it works

1. User navigates for the first time to website and server sets CSRF token and secret as cookies
2. For POST/PATCH/PUT/DELETE request, server will check secret against the value of CSRF token sent by client (via input hidden field or HTTP request header)
3. Though CSRF token will be sent back by client as cookie, server will ignore as it will only look for it in request body/query string/headers
4. Code that generates res.cookie('XSRF-TOKEN', req.csrfToken()) should be run once (per session)

#### Flaws in CSRF token validation

- Validation depends on request method i.e. GET, POST
- Validation depends on token being present, but skip if omitted
- CSRF token not being tied to the user session
- CSRF token is tied to a non-session cookie
- CSRF token is not stored but duplicated in cookie and request parameter

https://medium.com/dataseries/prevent-cross-site-request-forgery-in-express-apps-with-csurf-16025a980457
https://david-silva.medium.com/how-to-implement-csrf-protection-on-a-jwt-based-app-node-csurf-angular-bb90af2a9efd
https://dbillinghamuk.medium.com/csrf-setup-for-expressjs-and-ssr-react-redux-app-348e65261009
https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html

### Signed double-submit cookie

If maintaining the state for CSRF token on the server is problematic, you can use an alternative technique known as the Double Submit Cookie pattern. This technique is **easy to implement and is stateless**. There are different ways to implement this technique, where the **naive pattern** is the most commonly used variation.

The most secure implementation of the Double Submit Cookie pattern is the Signed Double-Submit Cookie, which uses a secret key known only to the server. This ensures that an attacker cannot create and inject their own, known, CSRF token into the victim's authenticated session. The system's tokens should be secured by hashing or encrypting them.

It is recommended to use **Hash-based Message Authentication (HMAC) algorithm** as it is less computationally expensive than encrypting and decrypting the cookie.

#### How it works

1. When an input form is requested, the web application generates a random token and sets it in a cookie
2. Browser reads the token from the cookie and sends it as a request parameter when submitting the form
3. Web application verifies if the cookie value and the value sent as request parameter match

### Same-Site cookies

SamSite is a cookie attribute which aims to mitigate CSRF attacks. This attribute should be implemented as an additional layer defense, and not replace a CSRF token.

Only cookies with a matching domain and path are sent to the server, but cookies are sent automatically with every request, regardless of whether the request was initiated by the original site or by a third party site.

The Strict value will prevent the cookie from being sent by the browser to the target site in all cross-site browsing context, even when following a regular link.

Though a cookie can set to same-site, not all modern browsers support them while older browsers do not support web applications that make use of same-site cookies.

Also, be careful **not to set a cookie specifically for a domain**. This action introduces a security vulnerability because all subdomains of that domain will share the cookie, and this is particularly an issue if a subdomain has a CNAME to domains not in your control.
